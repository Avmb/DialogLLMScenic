{
  "docstring": "Scenario Description\nTraffic Scenario 08.\nUnprotected left turn at intersection with oncoming traffic.\nThe ego-vehicle is performing an unprotected left turn at an intersection, yielding to oncoming\ntraffic.",
  "has_docstring": true,
  "body": "## SET MAP AND MODEL (i.e. definitions of all referenceable vehicle types, road library, etc)\nparam map = localPath('../../../tests/formats/opendrive/maps/CARLA/Town05.xodr')  # or other CARLA map that definitely works\nparam carla_map = 'Town05'\nmodel scenic.simulators.carla.model\n\n## CONSTANTS\nEGO_MODEL = \"vehicle.lincoln.mkz2017\"\nEGO_SPEED = 10\nSAFETY_DISTANCE = 20\nBRAKE_INTENSITY = 1.0\n\n## MONITORS\nmonitor TrafficLights:\n    freezeTrafficLights()\n    while True:\n        if withinDistanceToTrafficLight(ego, 100):\n            setClosestTrafficLightStatus(ego, \"green\")\n        if withinDistanceToTrafficLight(adversary, 100):\n            setClosestTrafficLightStatus(adversary, \"green\")\n        wait\n\n## DEFINING BEHAVIORS\nbehavior AdversaryBehavior(trajectory):\n    do FollowTrajectoryBehavior(trajectory=trajectory)\n\nbehavior EgoBehavior(speed, trajectory):\n    try:\n        do FollowTrajectoryBehavior(target_speed=speed, trajectory=trajectory)\n        do FollowLaneBehavior(target_speed=speed)\n    interrupt when withinDistanceToAnyObjs(self, SAFETY_DISTANCE):\n        take SetBrakeAction(BRAKE_INTENSITY)\n\n## DEFINING SPATIAL RELATIONS\n# Please refer to scenic/domains/driving/roads.py how to access detailed road infrastructure\n# 'network' is the 'class Network' object in roads.py\n\n# The meaning of filter() function is explained in examples/carla/Carla_Challenge/carlaChallenge7.scenic\nfourWayIntersection = filter(lambda i: i.is4Way and i.isSignalized, network.intersections)\n\n# make sure to put '*' to uniformly randomly select from all elements of the list\nintersec = Uniform(*fourWayIntersection)\nego_start_lane = Uniform(*intersec.incomingLanes)\n\n# Get the ego manuever\nego_maneuvers = filter(lambda i: i.type == ManeuverType.LEFT_TURN, ego_start_lane.maneuvers)\nego_maneuver = Uniform(*ego_maneuvers)\nego_trajectory = [ego_maneuver.startLane, ego_maneuver.connectingLane, ego_maneuver.endLane]\n\nego_start_section = ego_maneuver.startLane.sections[-1]\n\n# Get the adversary maneuver\nadv_maneuvers = filter(lambda i: i.type == ManeuverType.STRAIGHT, ego_maneuver.conflictingManeuvers)\nadv_maneuver = Uniform(*adv_maneuvers)\nadv_trajectory = [adv_maneuver.startLane, adv_maneuver.connectingLane, adv_maneuver.endLane]\n\nadv_start_lane = adv_maneuver.startLane\nadv_end_section = adv_maneuver.endLane.sections[0]\n\n## OBJECT PLACEMENT\nego_spawn_pt = OrientedPoint in ego_maneuver.startLane.centerline\nadv_spawn_pt = OrientedPoint in adv_maneuver.startLane.centerline\n\nego = Car at ego_spawn_pt,\n    with blueprint EGO_MODEL,\n    with behavior EgoBehavior(EGO_SPEED, ego_trajectory)\n\nadversary = Car at adv_spawn_pt,\n    with behavior AdversaryBehavior(adv_trajectory)\n\nrequire (ego_start_section.laneToLeft == adv_end_section)  # make sure the ego and adversary are spawned in opposite lanes\nrequire 25 <= (distance to intersec) <= 30\nrequire 15 <= (distance from adversary to intersec) <= 20\nterminate when (distance to ego_spawn_pt) > 70"
}